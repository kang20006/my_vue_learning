##intoduction
two way of using vue (1. stand alone widget 2. full website)
vue widget or components
vue website (single page applcation) (full)
-single html page sent (initially)
-not constantly sent request to server
-vue js bundle to render vue components
-linking and routing
-faster and smoother

##vue 3 new features
-composition api
-multiple root elements (side-by-side in a component)
-teleport component (render content from one compoent in a different place)
-suspense component
-typescript support

##environment
-vscode extension: live server,vetur

##lesson1
stand alone widget
-create html page (index.html)
-right click html then open with liver server
-cdn link
<script src="https://unpkg.com/vue@3"></script>
-create app.js to keep vue code
-vue not use semicolon

1.component in vue (data,methods,template)
2.dynamic rendering {{}}
3.v-on:click=""
4.@click=""
5.v-if=""
6.v-else
7.v-show

##lesson2
1. mouse event handling
2. attribute binding v-bind
3. v-for
4. conditional class
5. computed propertises (depend on data, create and manipulate new array)
6. access list

##lesson3
vue cli
use modern javascript features
live reload dev server
optimize code
#to install
1. install node.js
2. npm install -g @vue/cli
#create vue project
1. vue create model-project
2. manually select features
3. unselect linter
4. save babel in dedicated config file

#project file walk through
1. node_modules store dependencies, vue library
2. public consists of index.html
3. src source folder, store components, template, css
 have main.js that kicks start our application
 import {createApp} from 'vue'
 take function createApp from vue library in node_modules
 import App from ./App.vue
 App is the root component
 createApp(App).mount('#app') mount it to DOM with id app
 App.vue
 consists of template, script, style
4. babel config config so that we can use certain javascript features
5. package.json tack all our dependencies

start up local development server
cd to directory
npm run serve

we must have separate different component in different file
'footer,header,....'
can have as many root component in the template for vue3

npm install 
to install the node node_modules listed in package.json

#template refs
not query selector
template refs
<input type="text" ref="name">
access the refs
handleClick(){
      console.log(this.$refs.name)
    }

#multiple components
store in the components file
App.vue is the root component (parent component)
Header.vue,Footer.vue,... nested in root component (child component)

##lesson4
#scopped css and global css
<style> vs <style scoped>
advisible to use <style> only
if aim for specific component use .model h1
create global.css in assets
import it into main.js
import './assets/global.css'

#prop
pass data from parent to child component
make component more reusable
multiple component use same data, we only need to define the data in single place

<MyModal header="Sign up for the Give Away!"/>
props:['header']
<h1>{{ header }}</h1>
we can only pass in string

to use other than string we need data binding
i.e array
<MyModal :header="['AAA',4]"/>

we can also dynamically insert class

<div class="modal" :class="{sale:theme==='sale'}">
<MyModal :header="header" :text="text" theme="sale"/>

#custom events
we dont have access of method in other component
custom event can be fired from a child component and listen to parent component
in model:
- <div class="backdrop" @click="closeModal"> 
- closeModal(){
          this.$emit('close')
      }
(when click on div trigger closeModal function then emit colse event)
in App:
-<MyModal :header="header" :text="text" theme="sale" @close="toggleModal"/>
(when close event happened it trigger function toggleModal in App)

#click event modifier
-@click.right
-@click.shift
-@click.alt
-@click.self (click on self not other element in it)

#slots
-if we have form we cant pass whole form into the props
-put in custom template
-pass template into component
-default content will only show if we didnt pass in any content inside
<slot>default contents</slot>
will pass into everything inside tag <MyModal><MyModal/>

#name slots
useful when you have certain structure inside component 
<template v-slt:links>
        <a href="a">sign up now</a>
        <a href="a">more info</a>
</template>
<slot name="links"></slot>

#teleport
make certain html component outside the div with id app
<teleport to=".modals" v-if="showModal">
    <MyModal :header="header" :text="text" theme="sale" @close="toggleModal">
    </MyModal>
</teleport>
in the html
<div class="modals"></div>


##lesson5
reaction timer
#quickly show template, export defalut,.....
type vue choose first one
:disabled="isPlaying" js properties to diable button

#lifecycle hooks
mounted{} -> updated{} -> unmounted{}

first we put in delay as a props
when a component mounted
we start a time out
fire that code after the amount of time
after the amount of time we let showblock to be true
then the green block show on the screen
and start the timer
// every 10 ms + 10 to the reactionTime
// start right after showBlock true
    startTimer(){
            this.timer=setInterval( ()=>{
                this.reactionTime +=10
            },10 )
        },
// clear the timer when click
    stopTimer(){
            clearInterval(this.timer)
            console.log(this.reactionTime)
        },
    }

#customer event with data
how to fecth the data from the child back to parent
in MyBlock when stopTimer triger it emit a signal end
it bring along the this.reactionTime
stopTimer(){
            clearInterval(this.timer)
            console.log(this.reactionTime)
            // pass along the this.reactionTime
            this.$emit('end',this.reactionTime)
        },

in App when signal end detected
<MyBlock v-if="isPlaying" :delay="delay" @end="endGame"/>
endGame(reactionTime){
      this.score=reactionTime
      this.isPlaying=false
      this.showResult=true
    }
save the reaction time in score
